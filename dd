package main

import (
	"fmt"
	"math/rand"
	"time"
)

func createHugeRandomSliceInt(n int) []int {
	res := make([]int, n)
	for i := range res {
		res[i] = rand.Intn(10000)
	}
	return res
}

func main() {

	test1 := createHugeRandomSliceInt(300000) //[]int{1000, 4, 300, 0, 1, 1, 2, 1, 0}
	test := test1
	//9846 5799 7751 4324 3312
	//test := []int{9846, 5799, 7751, 4324, 3312}
	t := time.Now()
	qsort(test)
	d1 := time.Now().Sub(t)
	fmt.Println("test:", "size:", len(test), "time:", d1)
	fmt.Println("isSorted:", isSorted(test))

	test = test1
	t = time.Now()
	quickSort(test, 0, len(test)-1)
	d2 := time.Now().Sub(t)
	fmt.Println("test:", "size:", len(test), "time:", d2)
	fmt.Println("isSorted:", isSorted(test))

	fmt.Printf("mine is faster x%.2f times\n", float64(d2)/float64(d1))
}

// первая ссылка гугла. реализация в лоб
func quickSort(arr []int, low int, high int) {
	if low < high {
		pi := partion(arr, low, high)

		// Recursively sort elements before partition and after partition
		quickSort(arr, low, pi-1)
		quickSort(arr, pi+1, high)
	}
}

func partion(arr []int, low int, high int) int {
	pivot := arr[high]
	i := low - 1

	for j := low; j < high; j++ {
		if arr[j] < pivot {
			i++

			arr[i], arr[j] = arr[j], arr[i]
		}
	}

	arr[i+1], arr[high] = arr[high], arr[i+1]
	return i + 1
}

// выдано YandexGPT2 :)
func isSorted(arr []int) bool {
	if len(arr) < 2 {
		return true
	}

	for i := 1; i < len(arr); i++ {
		if arr[i] < arr[i-1] {
			return false
		}
	}

	return true
}

// мой улучшенный алгоритм квиксорт
func qsort(s []int) int {
	//массив из нуля и 1 элемента уже отсортирован
	if len(s) < 2 {
		return 0
	}
	//нахождение среднего индекса массива
	middleId := len(s) / 2
	//функции сравнения (замыкание)
	smaller := func(i int) bool {
		if i < s[middleId] {
			return true
		}
		return false
	}
	bigger := func(i int) bool {
		if i > s[middleId] {
			return true
		}
		return false
	}
	//поиск значений больше середины слева
	leftIds := Find(s, 0, middleId, bigger)
	//поиск значений меньше середины справа
	rightIds := Find(s, middleId, len(s)-1, smaller)
	//замены значений
	middleId = Swap(s, leftIds, rightIds, middleId)
	//рекурсивный вызов для двух оставшихся половин
	qsort(s[0:middleId])
	if middleId < len(s) {
		qsort(s[middleId+1:])
	}
	return middleId
}

func Find[T compareble](s []T, low T, high T, f func(T) bool) []T {
	res := make([]int, 0)
	for i := range s[low : high+1] {
		id := i + low
		if f(s[id]) {
			res = append(res, id)
		}
	}
	return res
}
func Swap[T compareble](s []int, leftIds []int, rightIds []int, middleId int) int {
	if (len(leftIds) == 0) && (len(rightIds) == 0) {
		return middleId
	}
	if len(leftIds) == len(rightIds) {
		for i := range leftIds {
			s[leftIds[i]], s[rightIds[i]] = s[rightIds[i]], s[leftIds[i]]
		}
		return middleId
	}
	if len(leftIds) < len(rightIds) {
		for i := range leftIds {
			s[leftIds[i]], s[rightIds[i]] = s[rightIds[i]], s[leftIds[i]]
		}
		leftovers := rightIds[len(leftIds):]
		return Reflect(s, leftovers, middleId)
	}
	if len(rightIds) < len(leftIds) {
		for i := range rightIds {
			s[leftIds[i]], s[rightIds[i]] = s[rightIds[i]], s[leftIds[i]]
		}
		leftovers := leftIds[len(rightIds):]

		return Reflect(s, leftovers, middleId)
	}
	return middleId
}
func Reflect(s []int, Ids []int, middleId int) int {
	if len(Ids) == 0 {
		return middleId
	}
	lefty := middleId > Ids[0]
	iter := func(i int) {
		if middleId == i+1 {
			s[middleId], s[i] = s[i], s[middleId]
			middleId--
			return
		}
		if middleId == i-1 {
			s[middleId], s[i] = s[i], s[middleId]
			middleId++
			return
		}
		if i > middleId {
			s[middleId], s[middleId+1] = s[middleId+1], s[middleId]

			s[middleId], s[i] = s[i], s[middleId]
			middleId++
			return
		}
		if i < middleId {
			s[middleId], s[middleId-1] = s[middleId-1], s[middleId]

			s[middleId], s[i] = s[i], s[middleId]
			middleId--
			return
		}
	}
	if lefty {
		for i := len(Ids) - 1; i >= 0; i-- {
			v := Ids[i]
			iter(v)
		}
	} else {
		for _, i := range Ids {
			iter(i)
		}
	}
	return middleId
}
